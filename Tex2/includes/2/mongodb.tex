MongoDB is a schema-less document-oriented database developed by MongoDB Inc. with the support of Open Source community. It is also known as a flexible, fast and Multi-datacenter scalable system.
\subsubsection{Data design} 
MongoDB stores data as a document with a unique key. It allows to query data by the key and every other attribute(or field) of a document which also can be indexed to increase the performance of queries. The documents are grouped together in a collection and a collection is consist inside a database. It is more convenient to group documents with similar structure together in a collection but not mandatory. Mongodb has two principles that allow the users to represent the relationships: \textit{references} and \textit{embedded} documents~\citep{mongodb:org}. 

\paragraph{Embedded}\label{mongo:embedded}
An Embedded document captures the relationship between data by storing related data in a single document. The documents are structured as sub-document in the form of Arrays or Objects~\citep{nosql/comparision}. 

\paragraph{Reference}
MongoDB does not support joins queries, therefore related data is stored in a single document. In some cases, the related data can be stored in a separate collection. The relationship between data can be created by including links and references from one document to another as shown in Figure~\ref{fig:mongodb-ref-doc}.  The references between the data can be created in two ways:
\begin{itemize}
	\item {\textbf{Manual references}}
		In manual references, the application handles the relationship between the related data and the \textit{\_id} field of one document, which refers to another document. 
	\item \textbf{Database reference}(\textit{DBRefs})
	The DBRefs reference one document to another document using a first document's primary index field, collection name and optional database name. 

	% 	A document can be refer to another document with the help of collections of references.  where as referencing both collection name and database, MongoDB allows a document reference to multiple database.   With the reference of collection, a document can be reference to another document belonging different collection.
\end{itemize}

\begin{figure}[h]
	\centering
	\subfloat[Reference document]{
		\includegraphics[width=0.44\textwidth]{img/mongodb-reference}
		%\caption{R-tree structure}
		\label{fig:mongodb-ref-doc}
	}
	\centering
	\subfloat[Embedded document]{
		\includegraphics[width=0.44\textwidth]{img/mongodb-embedded}
		%\caption{R-tree}
		\label{fig:mongodb-emb-doc}
	}
	\caption{MongoDB document structure~\citep{mongodb:org}}
	\label{fig:mongodb-doc}
	
\end{figure}

\paragraph{Document}
	A document is an abstract and storable unit in MongoDB. It is the data structure expressed in the form of JSON and is stored in BSON, a binary variant of JSON that supports additional data types like ObjectId, timestamp, datetime etc. All the accessible data including database records, query selectors, index specifications, server configurations etc. are represented as documents. A simpel MongoDB document is given in Figure~\ref{sample-mongodb-document}.
	\begin{figure}[h]
	\begin{lstlisting}[language=JSON,basicstyle=\scriptsize]
	{
		_id : "1"
		title : " MongoDB ",
		last_editor : "172.5.123.91" ,
		last_modified : new Date ("9/01/2015") ,
		body : " MongoDB is a..." ,
		categories : ["A", "B"] ,
		reviewed : false
	}
	\end{lstlisting} 
	\caption{MongoDB sample document}
	\label{sample-mongodb-document}
\end{figure}

\subsubsection{Indexing}\label{mong-xmark-indexing}
Each document in MongoDB is uniquely identified by a field \textit{\_id} which is also a primary index. Hence, the collection is sorted by \textit{\_id}~\citep{nosql/comparision}.
Apart from the primary index, MongoDB provides the mechanism to create secondary indexes for all fields of document. It supports various user defined indexes for field values of documents including single field index, multikey index, multidimensional index, geo-spatial index, text index and hash index.
%Single field, multidimensional and multikey indexes are organized using B-tree, whereas geospatial index is implemented using quad trees.
\begin{itemize}
\item \textit{Single field index} only includes data from a single field of documents in a collection.
\item \textit{Compound index} holds reference to the multiple fields within a collection's documents.
\item To index a field that contains an array value, MongoDB provides special indexing called \textit{Multikey index}.
\item \textit{Text index} helps efficient search of a string in documents.
\end{itemize}

\subsubsection{Query Model}%\todo{modify with christian's suggestions}
Queries in MongoDB are expressed in a JSON-like syntax and send to MongoDB as BSON objects by a database driver\citep{orend2010analysis}. A query can be specified by exact match on the embedded document or by using individual field with a \textit{dot notation} which is used to access an element in document of an array or an object in the form of  $<$$array$.$index$$>$ or  $<$$object$.$childobject$$>$. For general queries, mongo shell can be used. it an user friendly JavaScript shell and allows to implements callback functions to manipulates data return by the simple queries.  
\par
The Query model supports the following features:
\begin{enumerate}
	\item Queries over documents, embedded subdocuments and arrays
	\item Comparison operators
	\item Conditional Operators
	\item Logical Operators: AND and OR
	\item Sorting 
	\item Grouping
	\item Aggregation per query
\end{enumerate}


The \textit{find()} method is the most common way to retrieve data from a collection. It returns the subset of documents from specified collection with given criteria that are passed as parameters. If no any parameters is given, it returns everything from a collection.  The General syntax of find operation is given in Code~\ref{mongodb-find-sample}.
\begin{lstlisting}[language=JSON,caption=\textit{find} in MongoDB, label=mongodb-find-sample][H]
    db.collection.find(query, projection) 
\end{lstlisting}
 The \textit{query} specifies the criteria of document similar to SQL's WHERE clause in document format of a collection name \textit{collection}. The \textit{projection} selects of attributes of an documents to be return. For example, Code~\ref{mongodb-find-real} return the \textit{name} and \textit{age} from a collection  \textit{people} of country \textit{France} and \textit{age} is less than 5. 
\begin{lstlisting}[language=JSON,caption=\textit{find()} with query and project, label=mongodb-find-real][H]
    db.people.find({country:"France", age:{$lt:5}}, {_id:0, age:1, name:1}) 
\end{lstlisting}

\par
\paragraph{Aggregation Frameworks:}

 The \textit{find} method is not sufficient for the complex database queries like aggregation, grouping  and advanced data manipulation. MongoDB provides two frameworks for  advanced query as well as parallel processing for the large documents collection:
 \begin{itemize}
		\item{ \textbf{Aggregation pipeline}} allows to execute series of operations using different operators like filtration, projection to produce desire result or perform aggregation.  It can be used for a single collection and uses  data operators like match, group, project, etc. in different stages. Every stage convert the documents as they pass through the pipeline. Data operators can be used  in any numbers of times.  The \textit{aggregate} function is responsible for this framework where it operates on a collection passing  entire documents into pipeline. By using proper filtration operators like  skip, match and limit at the beginning  stage of the pipeline,  the frameworks can take advantages of existing indexes with processing scope limited to subset of documents  hence produces better performance in following stages~\cite{mongodbaggregation}. MongoDB's pipeline aggregation consists of many limitations including data types, memory restriction to operators and output size~\cite{nosql/comparision}. 
		
				   \begin{lstlisting}[language=JSON,caption=An example Aggregation pipeline in MongoDB, label=mongodb-aggregation-pipeline, basicstyle = \scriptsize][h]
            db.open_auctions.aggregate([
                {$match:{reserve:{$exists:true}}},
		       {$project:{_id:0,reserve:{$multiply:["$reserve",2.20371]}}}
		       ]);
		  \end{lstlisting}
		  
		  \item{\textbf{MapReduce}} is a data processing framework for design to support large volumes of data that goes beyond the limitations and restriction of aggregation pipeline.  In MongoDB's Mapreduce operation,  \textit{map} applies to each input document and emits the key-value pair as output. Any arbitrary sorting and limiting  of single collection is performed before map stage. The reduce applies to the map's output where a key is associated with multiple values to return the aggregated data. The output of reduce may pass optionally through finalize function for further process the result of aggregation. Map-reduce functions are written in JavaScript and executed in MongoDB's demon process \~cite{mongodbaggregation}.  Unlike pipeline framework, Map-reduce support options for choosing to store result  data in a node as collection or  produce just output. 
		  
\end{itemize}		

\begin{longtable}{c|c}
	{\textit{map}} function(a) & {\textit{reduce}} function(b)\\
	\hline
	\begin{minipage}{.4\textwidth}
		\centering		
		\begin{lstlisting}[language=XML,basicstyle = \scriptsize,label=couchbase-map-sample]
map = function() {
	for (var i in this.tags) {
		var recency = 1 / (new Date() - this.date);
		var score = recency * this.score;
		emit(this.tags[i], {
			"urls": [this.url],
			"score": score
		});
	}
};	
		\end{lstlisting}		
	\end{minipage} &
	\begin{minipage}{.55\textwidth}
		\centering
		\begin{lstlisting}[language=JSON, basicstyle =\tiny, label=couchbase-reduce-sample]
reduce = function(key, emits) {
	var total = {urls: [],score: 0 }
	for (var i in emits) {
		emits[i].urls.forEach(function(url) {
			total.urls.push(url);
		}
		total.score += emits[i].score;
	}
	return total;
};
		\end{lstlisting}
	\end{minipage}\\
	\hline
	\begin{minipage}{.55\textwidth}
	\begin{lstlisting}[language=JSON, basicstyle =\tiny,]
        db.runCommand({"mapreduce" : "collection-name", "map" : map, "reduce" : reduce})
    \end{lstlisting}
	\end{minipage}\\
	\caption{Mapreduce in MongoDB}
	\label{mongdb-mapreduce}\\
\end{longtable}

%end here

\begin{comment}


\paragraph{System Architecture}
MongoDB can be run in two modes. In stand-alone mode, a single \textit{mongod} demon runs in a single node without any distribution and in shared mode various services are distributed to several nodes. 
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{img/mongo/clusters}
	%\caption{R-tree}
	\label{fig:mongodb-clusters}
\caption{MongoDB Clusters}
\end{figure} %reference




\end{comment}