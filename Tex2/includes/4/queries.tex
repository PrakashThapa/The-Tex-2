All the XMark queries are translated into NoSQL database queries focusing  on output result. If a database supports secondary indexes, they have been utilized for efficient result. There are some problems for following queries:
\begin{itemize}
\item Q4 and Q7 cannot be applied to NoSQL databases. These queries will be skipped during the measurement and analysis. Q7 does not match the the concept of the data model. 
\item In Q14, full text search is measured in XQuery. The MongoDB, Couchbase and RethinkDB do not implement full text search but it a substring search in these databases. 
\end{itemize}

\subsection{XMark Queries in MongoDB}

In MongoDB, all the possible query methods have been implemented to get the same result as of XQuery.  For an example, the \textit{find()} function can be used for Q1 to get result. As we can see in  Code~\ref{mongo-xmark-q1}, the collection is filtered with default index \textit{\_id}  and the second parameter specifies the \textit{name} field to be retrieved.  for advanced queries, the aggregation pipeline has been used for the query. 

As mentioned in ~\ref{nosql-mongodb}, MongoDB does not support join queries. All the queries that need more than one collection  Q8, Q9, Q10, Q11 and Q12  are processed through \textit{mongo shell}. The callback functions are used  to get for further processing. Queries that supports secondary indexes have been optimized. Without indexes, MongoDB has to scan every document in a collection to match the criteria of the query. MongoDB secondary index can be created by using \textit{createIndex} function as in Code~\ref{mongodb-create-index}. Some of the important queries are explained here:

\begin{itemize}
\item Q1 directly implements the default index \textit{\_id} due to the the our data model for MongoDB. First, the collection is filtered and then \textit{name} field is specified to be selected. 

\item for Q2 and Q3, first, two indexes in fields \textit{initial} and \textit{"bidder.increase"} of collection \textit{open\_auctions}  has been created. With various step of aggregation pipeline, result is returned.

\item A comparison operator is implemented in Q5 that can be easily optimized with index. A secondary index is created in field \textit{price} of \textit{closed\_auctions} collection. 
\item According to our data model for MongoDB, Q6 is the count of document in the collection \textit{regions}. This query is itself optimized
\item The Q8 is implements joins between two collections \textit{people} and \textit{closed\_auction}. An index in field \textit{buyer.person} has been implemented, thefore the person search is efficient. The Q9 implements same index of Q8 also added two new secondary indexes on \textit{regions} field of \textit{regions} collection which is also utilized in Q13.
\item For Q10, another inded is created on \textit{profile.interest} field of \textit{people}. A helper function is used to join and format the data for output.
\item For Q14, a \textit{text index} is created in a collection \textit{regions} that allow to search by any sub-strings in whole collection. The XQuery search for full text but in MongoDB is it only the substring search.

\item Q15 and Q16 are the two queries where result do not match in exact. Deep XPath in MongoDB is not possible same way as in XQuery. 

\item The quey Q18 implements user-defined function. In MongoDB, it has to process two steps. A used defined function is created and stored in database system configuration file. Then, through mapreduce it is implemented. Table~\ref{tbl:mongodb-q18} illustrates Q18 using mapreduce.

\item for Q19, a secondary index on field \textit{location} of collection \textit{regions} is used for sorting the data. The final query Q20 implements the aggregations, We have used mapreduce for which is simpler as compare to aggregation for this query.

\end{itemize}


\begin{figure}
\centering
\begin{lstlisting}[language=JSON, caption=XMark Query Q1 in MongoDB, label=mongo-xmark-q1]
		db.people.find({_id:"person0"},{_id:0,"name":1});
\end{lstlisting}

\centering
\begin{lstlisting}[language=JSON, caption=MongoDB secondary Index, label=mongodb-create-index]
             db.closed_auctions.createIndex({regions:1})
\end{lstlisting}

\begin{lstlisting}[language=JSON, caption=user-defined function in MongoDB, label=mongodb-user-defined-function]
         
\end{lstlisting}
\end{figure}



\begin{longtable}{c|c}
	\caption{ User-defiend function and implementation in MongoDB(Q18)}
	\label{tbl:mongodb-q18}\\
    {function } & {map-reduce}\\
	\hline
\begin{minipage}{.4\textwidth}
\begin{lstlisting}[language=JSON,basicstyle =\scriptsize]
    db.system.js.save({ 
        "_id": "reserve", 
        "value": 
            function(a){ 
                return 2.20371*a; 
            } 
    })
\end{lstlisting}
\end{minipage} &
\begin{minipage}{.4\textwidth}
\begin{lstlisting}[language=JSON,basicstyle =\scriptsize]
db.open_auctions.mapReduce(
    function() {
       if(this.reserve){
        emit(this._id, reserve(this.reserve));
       }    
    },
    function(key,values) {
        return Array.sum(values);
    },
    { "out": { "inline": 1 } }
 );
\end{lstlisting}
\end{minipage}
\end{longtable}


\subsection{XMark Queries in Couchbase}
 In Couchbase, everythinng queried against the views. The output of the views are queried like through programming interface. We have used Node.js for querying couchbase. 
 
 
 For join queries, multiple views have been defined and joined manually. All XMark queries have been queried and evaluated through Node.js in Couchbase. 
 %For Q14, the map function convert the JSON to string and filter for substring. 
Code~\ref{couchbase-q20} illustrates a sample example of XMark  Q20 with map and reduce functions. The full list of Couchbase Mapreduce can be found in ~\ref{couchbase-query-list}
\begin{lstlisting}[language=JSON, caption=XMark query Q20 in Couchbase Server, label=couchbase-q20,  basicstyle=\scriptsize]
	map:
	  function (doc, meta) {
	    if(doc.doctype=="people"){
	      var income = (doc.profile && doc.profile.income)? doc.profile.income : 0;
	      if(income >= 100000 ){
	    	 emit("preferred",1);
	      }else if(income < 100000 && 
	               income >= 30000) {
	        emit("standard",1);
	      }else if(income < 30000 &&
	           income > 0 ){
	       
	        emit("challenge",1);
	      } else {
	       emit("na",income);
	      }
	    }
	  }
 reduce:
	  _count
\end{lstlisting}

\subsection{XMark Queries in RethinkDB}
In RethinkDB, the performance of a read query can be improved through the secondary indexes. In XMark queries,  wherever possible, these indexes are utilized to improve the performance. The index should be defined in the query and can be used only in one of the four functions \textit{getAll()}, \textit{between()}, \textit{eqJoin()} and \textit{orderBy()}. Table~\ref{tbl:rethinkdb-index-query} illustrates an example of creating a secondary index and its usage in a query.
\begin{longtable}{c|c}
	\caption{ RethinkDB secondary index and Query for Q13}
	\label{tbl:rethinkdb-index-query}\\
    {Index} & {Query}\\
	\hline
\begin{minipage}{.3\textwidth}
\begin{lstlisting}[language=JSON,basicstyle=\scriptsize]
    r.table("regions")
        .indexCreate("regions")
\end{lstlisting}
\end{minipage} &
\begin{minipage}{.5\textwidth}
\begin{lstlisting}[language=JSON,basicstyle=\scriptsize]
r.table("regions")
.getAll("australia",{index:"regions"})
    .map({  
       item:{  
          name:r.row("name"),
          description:r.row("description")
       }
    })
\end{lstlisting}
\end{minipage}
\end{longtable}

For query Q1, the document can be retrieved by the primary key \textit{id} using \textit{get()} function due to the data model defined in ~\ref{xmark-nosql}. Unlike MongoDB, secondary index cannot be implemented directly in Q5 as \textit{filter()} do not support secondary index. An index \textit{buyer\_person} is created in field "buyer.person" of \textit{closed\_auctions} table for join query Q8. Similarly, the Q9 can be improved by creating indexes in the tables \textit{regions} and \textit{closed\_auctions}. Other queries like Q13 and Q19 is also evaluated using indexes. For substring search in Q14, the value of  field \textit{description} is converted into text and then it is matched for the sub-string. All the queries and indexes are used for RethinkDB is given in ~\ref{rethinkdb-query-list}.
