RethinkDB~\citep{rethinkdb} is a distributed database system to store  JSON documents and parallelize queries in multiple machines. Its query language is called ReQL and it is based on three main principles:
 \begin{itemize}
 \item  It is  embedded  as programming language. Queries are constructed by making function call in the programming language. 
 \item ReQL queries are chainable that can be passed as pipeline from one stage to another. Complex operation can be performed using series of simple queries together by using dot operators \. . 
 \item All the queries are executed in server without any intermediate network round trip between the server and clients.
 \end{itemize}
  
\subsubsection{Data Model}
RethinkDB stores JSON documents as binary in disk. The data type supported by RethinkDB JSON. 
There are two ways to model relationships between the documents in RethinkDB: 
\begin{itemize}
	\item \textbf{Embedded arrays:} In this method, the related sub-documents are inserted with a specific key inside a document as in MongoDB ~\ref{mongo:embedded}. The advantages of using embedded arrays are:
		\begin{itemize}
			\item The Queries tend to be simpler. 
			\item If a dataset is large and do not fit into RAM, data is loaded faster from disk as compared to tables. 
		\end{itemize}
		Disadvantages of embedded arrays are: 
		\begin{itemize}
			\item Everything should be loaded in memory for any operation. Any update to the document requires rewriting the full array to disk.
		\end{itemize}
		
	\item 
	\textbf{Multiple Table Approach:} In this approach, documents with similar structures are stored in multiple tables which are connected by reference key similar to collection in MongoDB. Unlike embedded arrays, operation of a table do not required to load data from reference table in memory.
\end{itemize}
\subsubsection{Query Model}
RethinkDB's query language ReQL is embedded as programming language and JavaScript expressions can be used anywhere as a part of the query. The anonymous function, also known as lamda function, is a part of the query language that gives more flexibility for retrieving data. All the ReQL queries are chainable therefore, the dot \{.\} operator at any point of query can be extended to multiple levels as shown in Code~\ref{reql-chainable}.
	\begin{lstlisting}[language=JSON,caption=Chainable Query in ReQL, label=reql-chainable, xleftmargin=-40pt][h]
		r.table("users").run(conn)
		r.table("users").pluck("last_name").run(conn)
		r.table("users").pluck("last_name").distinct().run(conn)
		r.table("users").pluck("last_name").distinct().count().run(conn)
	\end{lstlisting} 

Unlike other NoSQL databases, RethinkDB supports join queries between the tables in one-to-many or many-to-many relationships based on the requirement of the application in distributed manner. 
%start here from bechmarking section

\subsubsection{Indexing}
	RethinkDB uses B-Trees to store indexes. It provides an option to specify the attribute as a primary key at the time of table creation. \textit{id} behaves as a primary key if the attribute is not specified. In the existence of the primary key attributes, a document is indexed with its value. Otherwise, a random unique string is automatically generated to index the document.  Beside the primary index, RethinkDB supports simple, compound, secondary, geospatial  and arbitrarily computed indexes. Every query including update operations uses one and only one index. 
	\begin{itemize}
		\item \textit{Simple indexes} are created to retrieve or sort efficiently by a value of an attribute.
		\item \textit{Compound indexes} are used to retrieve document by multiple fields. 
		\item Multi indexes are the indexes for array value of a field. 
		\item Any arbitrary expression can be used to create index on any type of user defined expressions like lamda functions.
	\end{itemize}