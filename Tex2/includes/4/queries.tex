All the XQuery expressions are translated into NoSQL database queries based on the output result. In case of availability of secondary indexes, they have been created and utilized for efficient result. There are some problems for following queries:
\begin{itemize}
\item Q4 and Q7 cannot be applied to NoSQL databases. These queries will be skipped during the measurement and analysis. In Q7, XPath  wild cards cannot be used in NoSQL databases, which makes it impossible to perform the query. 

\item In Q14, full text search is measured in XQuery. MongoDB, Couchbase and RethinkDB do not support full text search, therefore  sub-string search is performed in these databases. 
\end{itemize}

\subsection{Queries in MongoDB}

In MongoDB, all the possible query methods have been implemented to get the same result as of XQuery.  For example, the \textit{find()} function can be used for Q1 to get result. As we can see in  Code~\ref{mongo-xmark-q1}, the collection is filtered with default index \textit{\_id}  and the second parameter specifies the \textit{name} field to be retrieved.  For advanced queries, the aggregation pipeline and mapreduce are used.   The \textit{allowDiskUse} option in aggregation pipeline is enabled, that allows to execute the query beyond the memory limit.

As mentioned in ~\ref{nosql-mongodb}, MongoDB has no support for  join queries. All the queries that need more than one collection  Q8, Q9, Q10, Q11 and Q12  are processed through \textit{mongo shell}. Secondary indexes are created only when queries can be optimized. Without indexes, MongoDB has to scan every document in a collection to match the criteria of the query. MongoDB secondary index can be created by using \textit{createIndex} function as in Code~\ref{mongodb-create-index}. Some of the important queries are explained here:

\begin{itemize}
\item \ref{mongodb-q-1} implements the default index \textit{\_id}. The collection is filtered with the criteria and the second parameter specified the field to be selected in \textit{find()}. 

\item Two queries \ref{mongodb-q-2} and \ref{mongodb-q-3}  return the bidder information from \textit{open\_auctions} collection.  The field \textit{bidder} is array type in all JSON. Different operators in aggregation pipeline are used to get the result.

\item In \ref{mongodb-q-5}, a comparison operator \textit{\$gte(>=)} is used to filter the collection and documents return number of document. This query can be optimized with an index. A secondary index is created in field \textit{price} of \textit{closed\_auctions} collection. 

\item According to our data model for MongoDB, \ref{mongodb-q-6} counts the number of documents in the collection \textit{regions}.

\item In \ref{mongodb-q-8}, the result is based on the join  between  \textit{people} and \textit{closed\_auction} collections. The \textit{buyer.person} of \textit{closed\_auctions} is indexed [\ref{mongodb-i-8}] that helps to efficient search in \textit{\$match} operator of aggregation pipeline.
 \item 
The  \ref{mongodb-q-9} has to join  three collections \textit{regions}, \textit{people} and \textit{closed\_auctions} to get result.  An index \ref{mongodb-i-8} from Q8 is utilized. Secondary index on \textit{regions} of \textit{regions}  is added for query Q9 which is also usable in Q13. 

\item The complex result generation query \ref{mongodb-q-10} uses a helper function in console which format the output. two \textit{categories} and \textit{collection}  have joins. An index  
in field \textit{profile.interest} of \textit{people} collection is created. 

\item Queries \ref{mongodb-q-11} and \ref{mongodb-q-12} are value join queries between \textit{open\_auctions} and \textit{people} collection. 

\item Query \ref{mongodb-q-13} utilized the index created on field \textit{regions} of \textit{regions} collection. 

\item For Q14, a \textit{text index} is created in a collection \textit{regions} that allow to search by any sub-strings in whole collection. 

\item Compared to XQuery representations \ref{mongodb-q-15} and \ref{mongodb-q-16} are relatively complex in all NoSQL databases including MongoDB, because the child axes original query need to rewritten in various aggregation stages.

\item Query \ref{mongodb-q-17} is another simple query in MongoDB. The \textit{find} function can be to check the criteria and projection. 

\item The quey \ref{mongodb-q-18} implements user-defined function. In MongoDB, it has to process two steps: A function is created and stored as document system collection \textit{system.js}. Afterwards, it is called through mapreduce. Table~\ref{tbl:mongodb-q18} illustrates Q18 using mapreduce.

\item For \ref{mongodb-q-19}, a field  \textit{location} is indexed in collection \textit{regions} for sorting the data by location. This query is also implemented through aggregation pipeline. 
\item
The final query \ref{mongodb-q-18} based on aggregations. Mapreduce comparatively simpler but also possible from pipeline. For our test we have implemented Mapreduce. 
\end{itemize}
Full list of MongoDB queries and index can be found in ~\ref{mongodb-query-list}

\begin{figure}
\centering
\begin{lstlisting}[language=JSON, caption=XMark Query Q1 in MongoDB, label=mongo-xmark-q1]
		db.people.find({_id:"person0"},{_id:0,"name":1});
\end{lstlisting}

\centering
\begin{lstlisting}[language=JSON, caption=MongoDB secondary Index, label=mongodb-create-index]
             db.closed_auctions.createIndex({regions:1})
\end{lstlisting}
\end{figure}



\begin{longtable}{c|c}
    \hline
	\caption{ User-defiend function and implementation in MongoDB(Q18)}
	\label{tbl:mongodb-q18}\\
    {function } & {map-reduce}\\
	\hline
\begin{minipage}{.4\textwidth}
\begin{lstlisting}[language=JSON,basicstyle =\scriptsize]
    db.system.js.save({ 
        "_id": "reserve", 
        "value": 
            function(a){ 
                return 2.20371*a; 
            } 
    })
\end{lstlisting}
\end{minipage} &
\begin{minipage}{.4\textwidth}
\begin{lstlisting}[language=JSON,basicstyle =\scriptsize]
db.open_auctions.mapReduce(
    function() {
       if(this.reserve){
        emit(this._id, reserve(this.reserve));
       }    
    },
    function(key,values) {
        return Array.sum(values);
    },
    { "out": { "inline": 1 } }
 );
\end{lstlisting}
\end{minipage}
\end{longtable}


\subsection{XMark Queries in Couchbase}
 In Couchbase, everything is queried with the views. The output of the views are queried through programming interface. For each query, the \textit{doctype} should be checked.  All XMark queries have been queried and evaluated through Node.js in Couchbase. Some of the important queries are illustrated here:
 
 \begin{itemize}
 \item Q1 is a simple query in which the map function emits \textit{id} and \textit{name} of document if the condition is matched.
 \item Q2 and Q3 are deeper array and object processing. Map function use JavaScript code to find the required objects or arrays elements to emit them. 
 \item Both Q5 and Q6 use the built-in \textit{\_count} in reduce section.
 \item The join operation in Couchbase is bit complicated as compare to other NoSQL database. Each \textit{doctype} should have a view and it can be implemented multiple times. For example, in case of Q11 and Q12, view on 
 \textit{open\_auctions} can be used for both queries.  The join operation is completed using programming interface. The Q8 contains two views, one selects the \textit{id} and \textit{name} field from \textit{people}. other view aggregates \textit{doctype} \textit{closed\_auctions} using reduce function with query option \textit{group\_level=1}. Finally, both views are combined using Node.js. 
 \item In Q14, the \textit{description} field in \textit{regions} are converted into string  that makes substring search possible.
 \newpage
 \item In Q18, for a user-defined function implementation, a JavaScript function is created at map section and called it during emit. 
 \item In Q19, a query parameter \textit{descending} set to \textit{false} for result in ascending order. 
 \end{itemize}
 

 Table~\ref{tbl:couchbase-q20} illustrates a sample example of XMark  Q20 with  mapreduce functions and the query parameters. The full list of Couchbase Mapreduce can be found in ~\ref{couchbase-query-list}.

\begin{longtable}{c|c|c}
	\caption{ XMark query Q20 in Couchbase Server}
	\label{tbl:couchbase-q20}\\
    {map} & {reduce} & {query}\\
	\hline
\begin{minipage}{.5\textwidth}
\begin{lstlisting}[language=JSON,basicstyle =\scriptsize]
function (doc, meta) {
    if(doc.doctype=="people"){
      var income = (doc.profile && doc.profile.income) ? 
                doc.profile.income : 0;
      if(income >= 100000 ){
    	 emit("preferred",1);
      }else if(income < 100000 && 
               income >= 30000) {
        emit("standard",1);
      }else if(income < 30000 &&
           income > 0 ){
       
        emit("challenge",1);
      } else {
       emit("na",1);
      }
    }
  }
\end{lstlisting}
\end{minipage} &
\begin{minipage}{.15\textwidth}
\begin{lstlisting}[language=JSON,basicstyle =\scriptsize]
     _sum
\end{lstlisting}
\end{minipage} &
\begin{minipage}{.2\textwidth}
\begin{lstlisting}[language=JSON,basicstyle =\scriptsize]
     group_level=1
\end{lstlisting}
\end{minipage}
\end{longtable}

\subsection{XMark Queries in RethinkDB}

In RethinkDB, the performance of a read query can be improved through the secondary indexes. For XMark queries,  wherever possible, these indexes are utilized. The index has to be defined in the query and can be used only in one of the four functions \textit{getAll()}, \textit{between()}, \textit{eqJoin()} and \textit{orderBy()}. Table~\ref{tbl:rethinkdb-index-query} illustrates an example of creating a secondary index and its usage in a query.
\begin{longtable}{c|c}
	\caption{ RethinkDB secondary index and Query for Q13}
	\label{tbl:rethinkdb-index-query}\\
    {Index} & {Query}\\
	\hline
\begin{minipage}{.3\textwidth}
\begin{lstlisting}[language=JSON,basicstyle=\scriptsize]
    r.table("regions")
        .indexCreate("regions")
\end{lstlisting}
\end{minipage} &
\begin{minipage}{.5\textwidth}
\begin{lstlisting}[language=JSON,basicstyle=\scriptsize]
r.table("regions")
.getAll("australia",{index:"regions"})
    .map({  
       item:{  
          name:r.row("name"),
          description:r.row("description")
       }
    })
\end{lstlisting}
\end{minipage}
\end{longtable}
Some of the importain queries in RethinkDB explained here.


For query Q1, the document can be retrieved by the primary key \textit{id} using \textit{get()} function.  ReQl has more features for arrays and objects compare to  other NoSQL databases that helped in Q2 and Q3. Due to native support for joins between table, join queries are more flexible in RethinkDB. An index \textit{buyer\_person} is created in field "buyer.person" of \textit{closed\_auctions} table for Q8. Similarly, the Q9 can be improved by creating indexes in the tables \textit{regions} and \textit{closed\_auctions}. Other queries like Q13 and Q19 is also evaluated using indexes. For substring search in Q14, the value of  field \textit{description} is converted into text and then it is matched for the sub-string. All the queries and indexes are used for RethinkDB is given in ~\ref{rethinkdb-query-list}.
